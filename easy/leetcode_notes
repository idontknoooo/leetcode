// General
// {
// 	1. Code to get faster running time in Leetcode
// 	{
		// x is input value
		static int x=[](){
			// toggle off cout & cin, instead, use printf & scanf
		    std::ios::sync_with_stdio(false);
		    // untie cin & cout
		    cin.tie(NULL);
		    return 0;
		}(); // add () because it create lambda function and CALLED it.
// 	}
// }
// Questions
// 1. Two Sum
// {
		#include <unordered_map> // include <unordered_map>
		unordered_map<int, int> map // hashmap in C++
		map.find(key) // map.find() find key, not value
		unordered_map<int, int>::iterator p = map.begin(); // iterator
		p->second; // value for key
		p->first; // key
		map[key] = value; // store pair in map
// }
// 7. Reverse Integer
// {
	// Use nemeric method instead of string method
	INT_MIN //: Minimum value for an object of type int (-2^15+1 or less)
	INT_MAX //: Maxmium value for an object of type int (2^15-1 or more)
	to_string(int) // Convert int to string
	stoi(string) // covert string to int
	stol(string) // convert string to long
	stoll(string) // convert string to long long
// }
// 13. Roman to Integer
// {
		// 1. https://en.wikipedia.org/wiki/Roman_numerals
		// 2. Think in both string and integer ways
		// 3. 重复数次：一个罗马数字重复几次，就表示这个数的几倍。
		// 4. 右加左减：
		// 		在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。
		// 		在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。
		// 5. 同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL。
		// 6. Declare Map with initialization
        unordered_map<char, int> mp {
	 	{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}
		};
		// 7. Last element of string s
		s.back(); // C++11
		s.back() = '!'; // Since back() return reference, you can assign new value to it
		s.front(); // first element of string, C++11
		// 8. Access String element
		s[i]; // pass reference
		s.at(i); // same as above
// }
// 14. Longest Common Prefix
// {
	// 1. Understand what is common prefix: same starting chars among different strings	
	// 2. Bucket Principal: The shortest decides everything. 
	// 		In this case, common prefix between first 2 string is crucial, 
	//		since that is the first common prefix
	// 3.  Simulate the process by using trivial example with pen
// }
// 20. Valid Parentheses
// {
	// 1. Stack methods:
		stack<int> s;
		s.size();
		s.top();
		s.pop(); // does NOT return anything, so usually combine with top() when use
		s.push();
		s.empty();
	// 2. String functions
		string s = "hello";
		string s1 = "world";
		s.compare(s1); // return 0 when two strings are same, <0 s is shorter or lower than s1
		s.find('c'); // search a char in string and return iterator, string::npos is not found
		s.find('string'); // search a string in string and return iterator
		std::size_t found = s.find('c');
		if(found!=std::string::npos)
			cout << "found at " << found << endl;
		std::size_t // Unsigned integral type. Alias of one of the fundamental unsigned integer types.
		// position does not match ANY char in string
		s.find_first_not_of(' '); // Searches the string for the first character that does not match any of the characters specified in its arguments.
		// ANY of char in search string
		s.find_first_of(''); // Searches the string for the first character that matches any of the characters specified in its arguments.
		s.find_last_not_of('dc'); // last one
		s.find_last_of('sc'); // last one
		s.insert(s.begin(),'something'); // insert string(char) or char at position(or iterator)
		s.insert(10, 3, '-'); // insert 3 '-' at position 10
	// 3. Ascii to compare neighbours
		if('{'+1 != (int)c) // check whether c == '}', which is match to '{'
// }
// 21. Merge Two Sorted Lists
// {
	// 1. Note Lists are SORTED!
	// 2. Use 2 pointers on lists and move them accordingly
	// 3. First Node can be discard, since it does NOT have a value
	// 4. Empty list doesn't matter, since the end of list is NULL
	// 5. Declare listnode
			// Definition for singly-linked list.
			struct ListNode {
			    int val;
			    ListNode *next;
			    ListNode(int x) : val(x), next(NULL) {}
			};
			ListNode* node = new ListNode(INT_MIN);
// }
// 26. Remove Duplicates From Sorted Array
// {
	// 1. Update vector using double pointer
	// 2. std functions:
	// get unique value placed from beginning of vector
		vector<int>::iterator it = std::unique(vec.begin(), vec.end()); 
		vec.erase(it, vec.end());	// erase from iterator a to iterator b
// }
// 27. Remove Element
// {
	// 1. Double pointer	
// }
// 28. Implement strStr()
// {
	// 1. Check the match size and see whether it is same as 'needle', O(n^2)
// }
35. Search Insert Position
{
	a. Binary Search: Need to remember
	b. Binary search will low(mid), thus use 'left' as return value
		When a number x is <= nums[right], always right=mid-1, since it doesn't matter whether it is less than or equal, x will always be before 'right'
		However, when a number x >= nums[left], it matters whether it is > or ==, since if it's > nums[left], x should be place after 'left'; if x == nums[right], x should be place before 'left'.
}
38. Count And Say
{
	a. A 3 nested loop question, not hard but need thoroughly thinking, better to write down
	b. convert int to char, int+'0'
	c. void swap(T a, T b) to swap return & tmp(next)
	d. Swap is everywhere: if a variable is replaced by another in each iteration, then add a tmp can solve it.
}
53. Maximum Array
{
	a. If current_sum > 0, then it will be useful for next number
		when current_sum > 0, if next < 0, then max will be the same, clear current value
							  if next > 0, then max will be current_sum+next
		when current_sum < 0, if next < 0, then max will be the same, clear current value
							  if next > 0, then max will be just 'next', since currrent_sum is useless
	b. have a variable calculate 'current_non_negative_sum' and a variable store 'max'
}
58. Length Of Last Word
{
	a. Find condition:
		Start point: first point from right where != ' ' 
		End point: after start point, first point where == ' '
	b. Increment a length variable, not counting the iteration of moving iterator 'i'
}
66. Plus One
{
	a. Analyze how numbers will change
		only way to carry is 9+1 (10%10==1)
		Only time to add element into vector is adding 1 at beginning (vec.insert(vec.begin(),1))
	b. Handle carry and adding element
}
69. Sqrt(x)
{
	a. Newton's Iterative Method need to remember
	int mySqrt(int x) {
        double ans    = x;
        double delta  = 0.0001;
        while (abs(pow(ans, 2) - x) > delta) {
            ans = (ans + x / ans) / 2;
        }
        return ans;
    }
	b. x0 = x (initial guess)
		Xn = X_n-1 - f(X_n-1)/f'(X_n-1)
		   = X_n-1 - (X_n-1^2-X)/(2*X_n-1)
		   = X_0 - f(X_0)/f'(X_0) - f(X_1)/f'(X_1) ..... 
	c. f(a) = a^2 - x
	   f'(a) = 2a
}
67. Add Binary
{
	a. Find carry condition
	b. char calculation: '1' - '0' == 1
		1 + '0' == ascii(1) == 49
		char(1) != char(1+'0') == 1 == char(49)
		int('0') == 48 != 0 = '0'-'0'
}
70. Climbing Stairs
{
	a. New step can be reach be climb 1 step from previous step (1 way), or 2 steps from pre-previous stop (1 way). 
	Also, the path to previous and pre-previous are totally different, because they have different numbers of steps.
	Thus, by adding two previous ways, you got new step.
}
83. Remove Duplicates From Sorted List
{
	Easy, remember this is a sorted list and only keep the first repeat number and unlink the rest.
}
88. Merge Sorted Array
{
	a. From the most right (not left)
	b. Handle nums2 mainly, since nums1 will stay in itself	
}
100. Same Tree
{
	a. Check whether a pointer is NULL:
		if(p)
			cout << "Not NULL" << endl;
		if(!p)
			cout << "Is NULL" << endl;
	b. Process:
	{
		Think about process
		Use character of Tree to 'devide branch' & 'recursion'
	}	
}
101. Sysmmetric Tree
{
	a. Think base case and recursion
	b. Create a helper function
	c. One trick: Use same root, but flip tree to compare original with fliped
}
104. Maximum Depth Of Binary Tree
{
	a. DFS method comes to mind, recursion
	b. BFS is also a solution, iteratively
}
107. Binary Tree Level Order Traversal II
{
	a. BFS solution, like Question_104. Need a Queue to pop parent layer
	b. std::reverse(vec.begin(), vec.end()) to reverse
}
108. Convert Sorted Array to Binary Search Tree
{
	a. BST left_child <= curr <= right_child, thus, root should be in middle of vector (left < middle < right, since vector is sorted) 
	b. Create new vector using interator:
		vector<int> leftints(vec.begin(), num.begin()+middle);
	c. Find all root, then assign it left & right child
	d. Do this as an iterative process
}
110. Balanced Binary Tree
{
	a. Need to understand the problem
		Each node's depth of two subtrees never different by more than 1.
	b. [1,2,3,4,null,null,9,8,null,null,10] one test case
	c. Only make sure it is balanced from bottom, it can be balanced up until top
	d. If only check 2 branch of root, it will miss the difference in each subtree. Check tree in 'b'
	e. The difference is the criteria for balance 
}
111. Minimum Depth of Binary Tree
{
	a. Very similar to "Max Depth BT", use recursion and modify a few feature
	b. [1,2] has min depth 2, not 1; Min depth: root to closest leaf; not root to root.
}
112. Path Sum
{
	a. Find the pattern: each recursion take (sum-curr->val) as search sum
	b. handle base case
	c. Special case, unless root is the only node, root cannot be only value of branch
		[1,2] find 1, return false, because only branch is 1->2, which sum to 3 not 1
}
118. Pascals Triangle
{
	a. If size of vector has a pattern, declare its size before add value. 'push_back' take time	 
	b. Find pattern
}
119. Pascal's Triangle II
{
	a. NICE to declare size in advance
	b. Base case:	
		level0 is [1]
		level1 is [1,1]
		level2: [1,2,1]
	c. Nicer solution is solve from end
}
121. Best Time To Buy and Sell Stock
{
	a. When there is a example, try to go through it until the end. This helps understand question.
}
122. Best Time To Buy and Sell Stock II
{
	a. Mathematics: 
		Suppose a <= b <= c <= d, Max difference is d-a = (b-a)+(c-b)+(d-c)
		Since for this question, you can't engage in multiple transaction.
		Thus, the best we can do is: (b-a) + (d-c) <= d-a
		Thus, as long as there is an increase sequence, (d-a) is the max value
}
125. Valid Palindrome
{
	#include <cctype>
	a. isalnum(): check whether ialphanumeric (A-Za-z0-9)
	b. isalpha(): Check whether letter (A-Za-z)
	c. isdigit(): check whether digit (0-9)
	
	d. Start from 2 sides, faster
}
136. Single Number
{
	a. A XOR A == 0;
		0 ^ A == A, where A!=0	
	b. Use 0^A, iterate entire vector, return A
	c. accumulate(iter.begin(), iter.end(), init_val, binary_operation)
		#include <functional> // C++11
		#include <numeric> // accumulate
		accumulate(vec.begin(), vec.end(), 0, bit_xor<int>());
}
141. Linked List Cycle
{
	a. Faster-slower runner method, faster will meet slower eventually
	b. unordered_set methods 
}
155. Min Stack
{
	a. Stack is faster than vector
	b. To make constant min value return, spend time on storing val when do other operations
}
157. Read N Characters Given Read4
{
	a. For this question, read4() can be only used in one clause for read, otherwise, it will messed up
	b. when count iteration, use minus or division, two choice pick the best
		15 4
		15-4 leave 3, i-=4
		15/4 mod 3, need variables for dividend & mod
}
160. Intersection Of Two Linked Lists
{
	a. If no intersection, both node move to null
	b. To make two lists iterate in same pace, just need to find their length difference
	c. Then the longer one start from (length - diff) so they will in same pace
}
167. Two Sum II - Input Array Is Sorted
{
	a. This question assume there must be a solution (two numbers)
	b. Start from 2 end, 
		if sum > target, right end move left
		if sum <= target, left end move right
		if sum == target, return vector<int> ({left, right})
}
168. Excel Sheet Column Title
{
	a. Handle a(1) & z(26) special case
	b. Use n/26 to generate each leter
	c. Also, see a recursive method
	d. Number to Letter: (--num%26) + 'A'
		1 -> A
		26-> Z
		[1-26] % 26 = [1-25,0]
		[0-25] % 26 = [0, 25]
}
