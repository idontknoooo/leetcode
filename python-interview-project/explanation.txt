###################################################################################
##############################---Question1---######################################
###################################################################################

- Time Complexity: O(n-m) 
    n: length of s
    m: length of t

- Space Complexity: O(1)
    dictionary take O(1), nothing else take space in question1(s, t)

- Iterate through all substring (call it 'sbs') in 's' where len(sbs) == len(t)
For each 'sbs', check if sbs == anagram(t):
    if Yes: return True
    else: return False
   
- Code Explain:
    a. is_anagram(s,t): Check if s & t are anagrams
    b. question1(s,t): find 'sbs' in 's' and check whether 'sbs' is anagram of 't'
    
- Used for loop and sorting algorithm in Python



###################################################################################
##############################---Question2---######################################
###################################################################################

- Time Complexity: O(n^2)
    n for iterate through 's' in a for loop
    nested n for brutal force search palindrome

- Space Complexity: O(1)
    Only res take longest palindrome in question2(s)
     
- For each element in string 's', search palindrome, and only keep the longest

- Code Explain:
    a. helper(s,l,r): Find the longest palindrome for given an element in the string
    b. question2(s): Brutal force search the longest palindrome based on each element, the longest palindrome will be kept and return
        
- Used for loop, nested loop and function in Python



###################################################################################
##############################---Question3---######################################
###################################################################################

- Time Complexity: O(|V|^2)
    V: Vertex, |V| number of vertex
    Using adjacency matrix, go through row & column

- Space Complexity: O(|V|^2)
    Adjacency matrix takes |V|^2 space, MST take space of O(|V|) which is dominated by adjacency matrix
        
- Use Prim's Algorithm and adjacency matrix to find MST

- Code Explain:
    a. Convert input dictionary to adjacency matrix
    b. Apply Prim's Algorithm (given visited vertex and their edge, find min weight to unvisited vertex. Prim's Algo is a greedy algo)
    c. Add each selected edge to mst dictionary
        
- Used Prim's algorithm and adjacency matrix (2D list) in Python



###################################################################################
##############################---Question4---######################################
###################################################################################

- Time Complexity: O(logm*logn)
    logm: Search n1's parent
    logn: Search n2's parent 

- Space Complexity: O(logm)
    list of n1's parent take O(logm) space
    
- Find all parent for n1 and check the parents for n2, return the first parent of n2 appeared in n1's parents list

- Code Explain:
    a. parent(T, node): return parent of node
    b. question4(T, r, n1, n2): Calculate all parents for n1 and store them in a list, find the parent of n2 which appear first in n1's parent list, return first appear common parent, if not find return root.
        
- Used recursion and list



###################################################################################
##############################---Question5---######################################
###################################################################################

- Time Complexity: O(n)
    a fast pointer will iterate until the last node 

- Space Complexity: O(1) for double pointer, O(n) for list method
    Double pointer only two pointer take space
    List method need a list of length n to store Linked List values
    
- Two methods provided here:
    list_method: Store linked_list in list and access element use []
    double_pointer_method: A fast pointer will start m steps in advance, when it reach the end, the slow pointer will reach m-th from the end

- Code Explain:
    a. class Node(object): Linked List structure
    b. print_ll(head): A helper function which will print the entire linked list
    c. list_method(head, m): find m-th from the end using a list
    d. question5(head, m): double pointer method. A fast pointer will start m steps in advance, when it reach the end, the slow pointer will reach m-th from the end
        
- Used linked list, double pointer method in Python

